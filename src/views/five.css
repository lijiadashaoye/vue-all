/****************
css 获取自定义data-*数据
attr() 目前支持的仅有伪元素的 content 属性
******************/
.self-data span[data-descr] {
    position: relative;
    text-decoration: none;
    color: #00f;
    cursor: help;
    padding-left: 50px;
}

.self-data span[data-descr]:hover::after {
    content: attr(data-descr);
    position: absolute;
    left: 90px;
    top: 0px;
    min-width: 180px;
    border: 1px #aaaaaa solid;
    border-radius: 10px;
    background-color: #ffffcc;
    padding: 2px 5px;
    color: #000000;
    font-size: 14px;
    z-index: 1;
}

.self-data span[data-descr]:hover::before {
    content: '::before';
    position: absolute;
    left: -5px;
    top: 0px;
    color: #000000;
    font-size: 14px;
    z-index: 1;
}

/****************
css 动画
animation-name：指定@keyframes描述动画关键帧的规则名称。可以依次写出多个动画
animation-duration：配置动画完成一个周期所需的时间。默认值为0s，表示无动画。
animation-timing-function：通过建立加速曲线，动画如何在关键帧之间过渡。
animation-delay：配置元素加载时间与动画序列开始之间的延迟。
animation-iteration-count：配置动画应重复的次数，任何大于零的数字，不可为负值；您可以指定infinite无限期重复动画，。
animation-direction：配置动画在序列中每次运行时是否应交替显示方向或重置为起点并重复自身，
常用值：alternate动画交替反向运行，反向运行时，动画按步后退，同时，带时间功能的函数也反向，比如，ease-in 在反向时成为ease-out。

animation-fill-mode 设置CSS动画在执行之前和之后如何将样式应用于其目标。
forwards：会在动画结束时，保持最后一帧样式
backwards：在应用于目标时立即应用第一个关键帧中定义的样式值

animation是以上属性的简写集合，只需将每个属性的可用值依次罗列出来即可；
animation:  3s alternate 3 slidein; 或 animation: alternate 3s 3 slidein;

// 可以添加js监听动画事件
element.addEventListener("animationstart", listener, false);
element.addEventListener("animationend", listener, false);
element.addEventListener("animationiteration", listener, false);
******************/

.animation>p {
    animation-name: slidein, rotated;
    animation-duration: 3s, 3s;
    animation-iteration-count: 3, 3;
    animation-direction: alternate;
    animation-fill-mode: none, forwards;
}

@keyframes slidein {
    from {
        margin-left: 200%;
        width: 300%;
    }

    to {
        margin-left: 0%;
        width: 100%;
    }
}

@keyframes rotated {
    from {
        color: red;
        font-size: 12px;
    }

    to {
        color: green;
        font-size: 22px;
    }
}

/***********************
使用文字对背景图进行剪切
background-attachment：决定背景图像的位置是在视口内固定 fixed，还是随着包含它的区块滚动 scroll。
************************/

.backgrounds p {
    display: inline-block;
    width: 200px;
    height: 180px;
    text-align: center;
    line-height: 60px;
    font-size: 55px;
    font-weight: bold;
    letter-spacing: 10px;
    /* transparent：透明效果 */
    color: transparent;
    background-image: url('../assets/timg.jpg');
    background-size: cover;
    background-clip: text;
    background-origin: content-box;
    background-position: top 0px right 0px;

}

/*************************************
           背景图缩写方法
*************************************/
.background2 {
    background: url('../assets/timg.jpg') honeydew no-repeat 10% 100% / 220px 120px;
}



/*************************************
        背景图缩写方法
*************************************/
.shadow {
    width: 150px;
    height: 50px;
    margin-top: 20px;
    background: rgb(245, 244, 244);
    /* 阴影也会随着圆角变化 */
    border-bottom-right-radius: 20px;
}

/* 阴影模糊半径：值越大，模糊面积越大，阴影就越大越淡。 不能为负值*/
/* 阴影扩散半径：取正值时，阴影扩大；取负值时，阴影收缩 */

.shadow1 {
    /* x偏移量 | y偏移量 | 阴影模糊半径 | 阴影扩散半径 | 阴影颜色 */
    box-shadow: 4px 4px 4px 5px rgba(69, 238, 134, 0.8);
}

.shadow2 {
    /* 插页(阴影向内) x偏移量 | y偏移量 | 阴影模糊半径 | 阴影扩散半径 | 阴影颜色 */
    /* inset时，x y 偏移量默认在 top left 数值为负数时，会定位到 right bottom */
    box-shadow: inset -4px 4px 4px -1px rgba(226, 110, 110, 0.7);
}

.shadow3 {
    /* 任意数量的阴影，以逗号分隔 */
    box-shadow: 5px 5px 2px 3px red, inset 2px 2px 2px 1px rgba(133, 226, 110, 0.7);
}



/*************************************
        border 的写法
*************************************/
.border {
    width: 170px;
    height: 100px;
    margin-top: 20px;
    background: rgb(221, 220, 220);
    box-sizing: border-box;
}

.border1 {
    /* 与margin一样，可以写4个，也可写两个*/
    border-width: 6px 14px 10px 20px;
    /*  border-width: 2px 8px;  */
    border-color: red blue sandybrown yellow;
    border-style: solid dashed ridge dotted;
}

.border2 {
    border-width: 4px 16px;
    border-color: indigo;
    border-style: solid;
}